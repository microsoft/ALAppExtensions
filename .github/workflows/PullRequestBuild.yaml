name: 'Pull Request Build'

on:
  pull_request_target:
    paths-ignore:
      - '**.md'
    branches: [ 'main' ]

defaults:
  run:
    shell: powershell

permissions:
  contents: read
  actions: read
  pull-requests: read

jobs:
  PullRequestHandler:
    runs-on: [ windows-latest ]
    steps:
      - name: Test Adding new action
        id: ChangedFiles
        run: |
          Write-host "Test Adding new action"

      - uses: actions/checkout@v3
        with:
          lfs: true
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Determine Changed Files
        id: ChangedFiles
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0

          if ('${{ github.event.pull_request.head.repo.full_name }}' -ne $ENV:GITHUB_REPOSITORY) {
              $sb = [System.Text.StringBuilder]::new()
              $headers = @{             
                  "Authorization" = 'token ${{ secrets.GITHUB_TOKEN }}'
                  "Accept" = "application/vnd.github.baptiste-preview+json"
              }
              $baseSHA = '${{ github.event.pull_request.base.sha }}'
              $headSHA = '${{ github.event.pull_request.head.sha }}'
              $url = "$($ENV:GITHUB_API_URL)/repos/$($ENV:GITHUB_REPOSITORY)/compare/$baseSHA...$headSHA"
              $response = Invoke-WebRequest -UseBasicParsing -Headers $headers -Uri $url | ConvertFrom-Json
              $location = (Get-Location).path
              $prfolder = [GUID]::NewGuid().ToString()
              Add-Content -Path $env:GITHUB_OUTPUT -Value "prfolder=$prfolder"
              $prPath = Join-Path $location $prFolder
              New-Item -Path $prPath -ItemType Directory | Out-Null
              $prfilesChanged = @()
              Write-Host "Files Changed:"
              $response.files | ForEach-Object {
                $filename = $_.filename
                $status = $_.status
                Write-Host "- $filename $status"
                $prFilesChanged += $filename
                $path = Join-Path $location $filename
                $newPath = Join-Path $prPath $filename
                $newfolder = [System.IO.Path]::GetDirectoryName($newpath)
                $extension = [System.IO.Path]::GetExtension($path)
                $name = [System.IO.Path]::GetFileName($path)
                if ($extension -eq '.ps1' -or $extension -eq '.yaml' -or $extension -eq '.yml' -or $name -eq "CODEOWNERS") {
                  throw "Pull Request containing changes to scripts, workflows or CODEOWNERS are not allowed from forks."
                }
                if (-not (Test-Path $newfolder)) {
                  New-Item $newfolder -ItemType Directory | Out-Null
                }
                if ($status -eq "renamed") {
                  Copy-Item -Path $path -Destination $newfolder -Force
                  $oldPath = Join-Path $prPath $_.previous_filename
                  $oldFolder = [System.IO.Path]::GetDirectoryName($oldpath)
                  if (-not (Test-Path $oldFolder)) {
                    New-Item $oldFolder -ItemType Directory | Out-Null
                  }
                  New-Item -Path "$oldPath.REMOVE" -itemType File | Out-Null
                }
                elseif ($status -eq "removed") {
                  New-Item -Path $newfolder -name "$name.REMOVE" -itemType File | Out-Null
                }
                else {
                  Copy-Item -Path $path -Destination $newfolder -Force
                }
              }
              Set-Content -path (Join-Path $prPath ".PullRequestCommentId") -value '${{ steps.CreateComment.outputs.comment_id }}' -Encoding UTF8 -NoNewLine -Force
              Set-Content -path (Join-Path $prPath ".PullRequestFilesChanged") -value $prFilesChanged -Encoding UTF8 -Force
          }

  Initialization:
    runs-on: [ windows-latest ]
    outputs:
      telemetryScopeJson: ${{ steps.init.outputs.telemetryScopeJson }}
      settings: ${{ steps.ReadSettings.outputs.SettingsJson }}
      projects: ${{ steps.ReadSettings.outputs.ProjectsJson }}
      projectCount: ${{ steps.ReadSettings.outputs.ProjectCount }}
      environments: ${{ steps.ReadSettings.outputs.EnvironmentsJson }}
      environmentCount: ${{ steps.ReadSettings.outputs.EnvironmentCount }}
      deliveryTargets: ${{ steps.DetermineDeliveryTargets.outputs.DeliveryTargetsJson }}
      deliveryTargetCount: ${{ steps.DetermineDeliveryTargets.outputs.DeliveryTargetCount }}
      githubRunner: ${{ steps.ReadSettings.outputs.GitHubRunnerJson }}
      githubRunnerShell: ${{ steps.ReadSettings.outputs.GitHubRunnerShell }}
      checkRunId: ${{ steps.CreateCheckRun.outputs.checkRunId }}
      projectDependenciesJson: ${{ steps.ReadSettings.outputs.ProjectDependenciesJson }}
      buildOrderJson: ${{ steps.ReadSettings.outputs.BuildOrderJson }}
      buildOrderDepth: ${{ steps.ReadSettings.outputs.BuildOrderDepth }}
      buildModes: ${{ steps.ReadSettings.outputs.BuildModes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          lfs: true

      - name: Initialize the workflow
        id: init
        uses: microsoft/AL-Go-Actions/WorkflowInitialize@v2.3
        with:
          shell: powershell
          eventId: "DO0091"

      - name: Read settings
        id: ReadSettings
        uses: aholstrup1/AL-Go-Actions/ReadSettings@main
        with:
          shell: powershell
          parentTelemetryScopeJson: ${{ steps.init.outputs.telemetryScopeJson }}
          getProjects: 'Y'
          getEnvironments: '*'

      - name: Determine Delivery Target Secrets
        id: DetermineDeliveryTargetSecrets
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $deliveryTargetSecrets = @('GitHubPackagesContext','NuGetContext','StorageContext','AppSourceContext')
          $namePrefix = 'DeliverTo'
          Get-Item -Path (Join-Path $ENV:GITHUB_WORKSPACE ".github/$($namePrefix)*.ps1") | ForEach-Object {
            $deliveryTarget = [System.IO.Path]::GetFileNameWithoutExtension($_.Name.SubString($namePrefix.Length))
            $deliveryTargetSecrets += @("$($deliveryTarget)Context")
          }
          Add-Content -Path $env:GITHUB_OUTPUT -Value "Secrets=$($deliveryTargetSecrets -join ',')"

      - name: Read secrets
        uses: microsoft/AL-Go-Actions/ReadSecrets@v2.3
        env:
          secrets: ${{ toJson(secrets) }}
        with:
          shell: powershell
          settingsJson: ${{ env.Settings }}
          secrets: ${{ steps.DetermineDeliveryTargetSecrets.outputs.Secrets }}

      - name: Determine Delivery Targets
        id: DetermineDeliveryTargets
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $deliveryTargets = @('GitHubPackages','NuGet','Storage')
          if ($env:type -eq "AppSource App") {
            $continuousDelivery = $false
            # For multi-project repositories, we will add deliveryTarget AppSource if any project has AppSourceContinuousDelivery set to true
            ('${{ steps.ReadSettings.outputs.ProjectsJson }}' | ConvertFrom-Json) | where-Object { $_ } | ForEach-Object {
              $projectSettings = Get-Content (Join-Path $_ '.AL-Go/settings.json') -raw | ConvertFrom-Json
              if ($projectSettings.PSObject.Properties.Name -eq 'AppSourceContinuousDelivery' -and $projectSettings.AppSourceContinuousDelivery) {
                Write-Host "Project $_ is setup for Continuous Delivery"
                $continuousDelivery = $true
              }
            }
            if ($continuousDelivery) {
              $deliveryTargets += @("AppSource")
            }
          }
          $namePrefix = 'DeliverTo'
          Get-Item -Path (Join-Path $ENV:GITHUB_WORKSPACE ".github/$($namePrefix)*.ps1") | ForEach-Object {
            $deliveryTarget = [System.IO.Path]::GetFileNameWithoutExtension($_.Name.SubString($namePrefix.Length))
            $deliveryTargets += @($deliveryTarget)
          }
          $deliveryTargets = @($deliveryTargets | Select-Object -unique | Where-Object {
            $include = $false
            Write-Host "Check DeliveryTarget $_"
            $contextName = "$($_)Context"
            $deliveryContext = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String([System.Environment]::GetEnvironmentVariable($contextName)))
            if ($deliveryContext) {
              $settingName = "DeliverTo$_"
              $settings = $env:Settings | ConvertFrom-Json
              if (($settings.PSObject.Properties.Name -eq $settingName) -and ($settings."$settingName".PSObject.Properties.Name -eq "Branches")) {
                Write-Host "Branches:"
                $settings."$settingName".Branches | ForEach-Object {
                  Write-Host "- $_"
                  if ($ENV:GITHUB_REF_NAME -like $_) {
                    $include = $true
                  }
                }
              }
              else {
                $include = ($ENV:GITHUB_REF_NAME -eq 'main')
              }
            }
            if ($include) {
              Write-Host "DeliveryTarget $_ included"
            }
            $include
          })
          $deliveryTargetsJson = $deliveryTargets | ConvertTo-Json -Depth 99 -compress
          if ($deliveryTargets.Count -lt 2) { $deliveryTargetsJson = "[$($deliveryTargetsJson)]" }
          Add-Content -Path $env:GITHUB_OUTPUT -Value "DeliveryTargetsJson=$deliveryTargetsJson"
          Write-Host "DeliveryTargetsJson=$deliveryTargetsJson"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "DeliveryTargetCount=$($deliveryTargets.Count)"
          Write-Host "DeliveryTargetCount=$($deliveryTargets.Count)"
          Add-Content -Path $env:GITHUB_ENV -Value "DeliveryTargets=$deliveryTargetsJson"

      - name: Determine Build Order
        if: env.workflowDepth > 1
        id: BuildOrder
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $projects = '${{ steps.ReadSettings.outputs.ProjectsJson }}' | ConvertFrom-Json
          $buildOrder = '${{ steps.ReadSettings.outputs.BuildOrderJson }}' | ConvertFrom-Json
          $depth = ${{ steps.ReadSettings.outputs.BuildOrderDepth }}
          $workflowDepth = ${{ env.workflowDepth }}
          if ($depth -lt $workflowDepth) {
            Write-Host "::Error::Project Dependencies depth is $depth. Workflow is only setup for $workflowDepth. You need to Run Update AL-Go System Files to update the workflows"
            $host.SetShouldExit(1)
          }
          $step = $depth
          $depth..1 | ForEach-Object {
            $ps = @($buildOrder."$_" | Where-Object { $projects -contains $_ })
            if ($ps.Count -eq 1) {
              $projectsJSon = "[$($ps | ConvertTo-Json -compress)]"
            }
            else {
              $projectsJSon = $ps | ConvertTo-Json -compress
            }
            if ($ps.Count -gt 0) {
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Json=$projectsJson"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Count=$($ps.count)"
              Write-Host "projects$($step)Json=$projectsJson"
              Write-Host "projects$($step)Count=$($ps.count)"
              $step--
            }
          }
          while ($step -ge 1) {
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Json="
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Count=0"
              Write-Host "projects$($step)Json="
              Write-Host "projects$($step)Count=0"
              $step--
          }